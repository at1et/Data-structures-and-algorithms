#ifndef ARRAY_UST_H
#define ARRAY_UST_H

// array_UST.h - Заголовочный файл с объявлениями и inline‑определениями функций для работы с массивами,
// а также классом Timer для измерения времени выполнения операций.
// Здесь описаны функции для генерации случайных чисел, заполнения массивов, последовательного поиска и записи массива в файл.

#include <cstddef>      // Для определения типа size_t
#include <string>       // Для работы со строками (std::string)
#include <functional>   // Для std::function (используется в шаблонных функциях поиска)
#include <chrono>       // Для измерения времени (std::chrono)
#include <iostream>     // Для стандартного ввода/вывода (std::cout)
#include <random>       // Для генерации случайных чисел
#include <ctime>        // Для работы со временем (необходим для инициализации генератора)
#include <fstream>      // Для работы с файловыми потоками (ofstream)
#include <cassert>      // Для использования функции assert

using namespace std;            // Используем стандартное пространство имён
using namespace chrono;           // Используем пространство имён chrono для удобства

//------------------------------------------------------------------------------
// ФУНКЦИИ 
//------------------------------------------------------------------------------

// Функция для получения ссылки на глобальный генератор случайных чисел.
// Реализация находится в файле array_UST.cpp.
mt19937& getRandomGenerator();

// Функция для создания динамического массива целых чисел заданного размера.
// Массив заполняется случайными числами в диапазоне [minVal, maxVal].
// Возвращает указатель на выделенную память.
int* createRandomArray(size_t size, int minVal, int maxVal);

// Функция для заполнения переданного массива целых чисел монотонно возрастающими значениями.
// Первый элемент выбирается случайно из диапазона [startMin, startMax].
// Каждый последующий элемент равен предыдущему плюс случайный шаг из диапазона [stepMin, stepMax].
void fillArrayRandomIncreasing(int* array, size_t size, int startMin, int startMax, int stepMin, int stepMax);

// Функция для записи содержимого массива в текстовый файл.
// Элементы массива разделяются пробелами.
void writeArrayToFile(const string& filename, const int* array, size_t size);

// Функция для проверки, отсортирован ли массив (по неубыванию).
// Возвращает true, если массив отсортирован, иначе – false.
bool isSorted(const int* array, size_t size);

// Функция для автоматического тестирования функции isSorted.
// Использует assert для проверки корректности работы.
void testIsSorted();

//------------------------------------------------------------------------------
// ШАБЛОННЫЕ ФУНКЦИИ ДЛЯ ПОСЛЕДОВАТЕЛЬНОГО ПОИСКА
//------------------------------------------------------------------------------

// Шаблонная функция для последовательного поиска заданного значения в массиве.
// Если значение найдено, возвращается его индекс, иначе – размер массива.
template <typename T>
size_t sequentialSearch(const T* array, size_t size, const T& value) {
    // Проходим по всему массиву от первого до последнего элемента
    for (size_t i = 0; i < size; ++i) {
        // Если текущий элемент равен искомому значению, возвращаем его индекс
        if (array[i] == value)
            return i;
    }
    return size; // Если значение не найдено, возвращаем size
}

// Шаблонная функция для последовательного поиска элемента, удовлетворяющего заданному предикату.
// Предикат передаётся как std::function<bool(const T&)>.
// Если найден первый элемент, для которого предикат возвращает true, возвращается его индекс, иначе – size.
template <typename T>
size_t sequentialSearch(const T* array, size_t size, const function<bool(const T&)>& predicate) {
    // Проходим по каждому элементу массива
    for (size_t i = 0; i < size; ++i) {
        // Если предикат возвращает true для текущего элемента, возвращаем его индекс
        if (predicate(array[i]))
            return i;
    }
    return size; // Если ни один элемент не удовлетворяет предикату, возвращаем size
}

//------------------------------------------------------------------------------
// КЛАСС Timer ДЛЯ ИЗМЕРЕНИЯ ВРЕМЕНИ
//------------------------------------------------------------------------------

// Класс Timer создаёт таймер при инициализации и выводит затраченное время (в мс) при выходе из области видимости.
class Timer {
public:
    // Конструктор принимает имя таймера (по умолчанию пустая строка).
    // Параметр name используется для идентификации таймера при выводе.
    Timer(const string& name = "")
        : name(name), start(steady_clock::now()) {} // Инициализируем имя и фиксируем время старта

    // Деструктор вызывается при завершении блока, в котором создан объект Timer.
    // Он вычисляет разницу между текущим временем и временем старта и выводит результат.
    ~Timer() {
        auto end = steady_clock::now();                             // Фиксируем конечное время
        auto delta = duration_cast<milliseconds>(end - start);        // Вычисляем разницу в миллисекундах
        cout << "Timer [" << name << "]: " << delta.count() << " ms" << endl; // Выводим имя таймера и время выполнения
    }
private:
    string name;                          // Имя таймера для вывода
    steady_clock::time_point start;       // Точка времени, когда был создан таймер
};

#endif // ARRAY_UST_H
