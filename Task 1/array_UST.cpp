#include "array_UST.h"  // Подключаем заголовочный файл, содержащий объявления функций и классов

//------------------------------------------------------------------------------
// РЕАЛИЗАЦИЯ ФУНКЦИЙ
//------------------------------------------------------------------------------

// Функция для получения глобального генератора случайных чисел.
// Статические переменные инициализируются один раз при первом вызове функции.
mt19937& getRandomGenerator() {
    static random_device rd;      // Источник энтропии для инициализации генератора
    static mt19937 gen(rd());       // Инициализируем генератор, используя rd для случайности
    return gen;                     // Возвращаем ссылку на статический генератор
}

// Функция для создания динамического массива целых чисел заданного размера.
// Массив заполняется случайными числами в диапазоне [minVal, maxVal].
int* createRandomArray(size_t size, int minVal, int maxVal) {
    int* array = new int[size];  // Выделяем память для массива из size элементов
    // Создаём равномерное распределение для генерации чисел от minVal до maxVal
    uniform_int_distribution<int> distr(minVal, maxVal);
    auto& gen = getRandomGenerator();  // Получаем ссылку на глобальный генератор случайных чисел
    // Заполняем массив случайными числами
    for (size_t i = 0; i < size; ++i) {
        array[i] = distr(gen);  // Для каждого элемента генерируем случайное число
    }
    return array;  // Возвращаем указатель на созданный массив
}

// Функция для заполнения переданного массива монотонно возрастающими числами.
// Первый элемент выбирается случайно из диапазона [startMin, startMax].
// Каждый последующий элемент равен предыдущему плюс случайный шаг из диапазона [stepMin, stepMax].
void fillArrayRandomIncreasing(int* array, size_t size, int startMin, int startMax, int stepMin, int stepMax) {
    if (size == 0) return;  // Если размер массива равен 0, выходим из функции
    auto& gen = getRandomGenerator();  // Получаем ссылку на генератор случайных чисел
    // Создаем распределение для начального значения
    uniform_int_distribution<int> startDistr(startMin, startMax);
    // Создаем распределение для шага между элементами
    uniform_int_distribution<int> stepDistr(stepMin, stepMax);
    array[0] = startDistr(gen);  // Заполняем первый элемент массива случайным числом
    // Заполняем оставшиеся элементы массива
    for (size_t i = 1; i < size; ++i) {
        // Каждый элемент равен предыдущему элементу плюс случайно сгенерированный шаг
        array[i] = array[i - 1] + stepDistr(gen);
    }
}

// Функция для записи содержимого массива в текстовый файл.
// Элементы массива разделяются пробелами.
void writeArrayToFile(const string& filename, const int* array, size_t size) {
    ofstream out(filename);  // Открываем файловый поток для записи в файл filename
    if (!out) {  // Если файл не удалось открыть, выводим сообщение об ошибке
        cerr << "Cannot open file " << filename << " for writing." << endl;
        return;
    }
    // Записываем каждый элемент массива в файл, разделяя их пробелом
    for (size_t i = 0; i < size; ++i) {
        out << array[i] << " ";
    }
    out.close();  // Закрываем файловый поток
}

// Функция для проверки, отсортирован ли массив (по неубыванию).
// Если массив содержит менее двух элементов, он считается отсортированным.
bool isSorted(const int* array, size_t size) {
    if (size < 2) return true;  // Массив из 0 или 1 элемента всегда отсортирован
    // Проходим по массиву, начиная со второго элемента
    for (size_t i = 1; i < size; ++i) {
        // Если предыдущий элемент больше текущего, массив не отсортирован
        if (array[i - 1] > array[i])
            return false;
    }
    return true; // Если нарушений не найдено, возвращаем true
}

// Функция для автоматического тестирования функции isSorted.
// Использует assert для проверки корректности работы.
void testIsSorted() {
    {
        int arr1[] = { 1, 2, 3, 4, 5 };  // Отсортированный массив
        assert(isSorted(arr1, 5) == true); // Проверяем, что функция возвращает true
    }
    {
        int arr2[] = { 5, 4, 3, 2, 1 };  // Массив, отсортированный в обратном порядке
        assert(isSorted(arr2, 5) == false); // Функция должна вернуть false
    }
    {
        int arr3[] = { 1 };  // Массив из одного элемента
        assert(isSorted(arr3, 1) == true); // Всегда отсортирован
    }
    {
        int arr4[] = { 1, 1, 1, 1 };  // Массив с одинаковыми элементами
        assert(isSorted(arr4, 4) == true); // Должен считаться отсортированным
    }
    {
        int arr5[] = { 1, 2, 2, 3, 2 };  // Массив, где последний элемент нарушает порядок
        assert(isSorted(arr5, 5) == false); // Должно вернуть false
    }
    // Если все проверки пройдены, выводим сообщение
    cout << "All isSorted tests passed." << endl;
}
