// Author: Полуэктов Андрей
//
// Задание 2. Анализ сложности алгоритма.
// Ссылка на задание: https://github.com/ivtipm/Data-structures-and-algorithms/blob/main/tasks/task_s1_alg_analysis.md
//
// Данная программа демонстрирует работу с классическими массивами, включает функции генерации
// случайных и монотонно возрастающих массивов, последовательный поиск (с вариантами) и измерение времени работы.

#include "max_product.h"  // Подключаем заголовочный файл с функцией
#include <iostream>       // Подключаем библиотеку для вывода в консоль

using namespace std;  // Используем стандартное пространство имён

int main() {
    setlocale(LC_ALL, "Russian");
    // Исходный массив чисел
    vector<double> arr = { 3, -1, 4, -2, 5, -6 };

    try {
        // Вызываем функцию maxProduct для поиска наибольшего произведения
        ProductResult res = maxProduct(arr);

        // Выводим исходный массив
        cout << "Исходный массив: ";
        for (double x : arr) {
            cout << x << " ";  // Выводим каждый элемент массива через пробел
        }
        cout << "\n";  // Переход на новую строку

        // Выводим результаты работы алгоритма
        cout << "Наибольшее произведение: " << res.product << "\n";
        cout << "Множители: " << res.factor1 << " и " << res.factor2 << "\n";
        cout << "Количество сравнений: " << res.comparisons << "\n";

        saveResultToFile("output.txt", arr, res);
        cout << "Результаты записаны в файл output.txt\n";

    }
    catch (const exception& e) {  // Если в массиве меньше 2 элементов, ловим ошибку
        cout << "Ошибка: " << e.what() << endl;  // Выводим сообщение об ошибке
    }

    return 0;  // Завершаем программу с кодом 0 (успешное выполнение)
}
